<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Python查询天气]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Python%E6%9F%A5%E8%AF%A2%E5%A4%A9%E6%B0%94/</url>
      <content type="html"><![CDATA[<h1 id="使用Python制作天气查询程序"><a href="#使用Python制作天气查询程序" class="headerlink" title="使用Python制作天气查询程序"></a>使用Python制作天气查询程序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原教程地址：<a href="http://crossincode.com/course/lesson_list/" target="_blank" rel="external">Crossin</a></p>
<p>这篇文章是我按照上面的教程学习后写的一篇笔记，由于我是<code>Python</code>初学者，如有不对的地方欢迎指出哦0v0</p>
<h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="http://linfile.xyz/data/vip_data/f_3356.png" alt="f_3356.png"></p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用了中国天气网的API。</p>
<ul>
<li><p>首先，在<a href="http://m.weather.com.cn/data5/city.xml" target="_blank" rel="external">http://m.weather.com.cn/data5/city.xml</a> 获取各个省的编号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">01|北京,02|上海,03|天津,04|重庆,05|黑龙江,06|吉林,07|辽宁,08|内蒙古,09|河北,10|山西,11|陕西,12|山东,13|新疆,14|西藏,15|青海,16|甘肃,17|宁夏,18|河南,19|江苏,20|湖北,21|浙江,22|安徽,23|福建,24|江西,25|湖南,26|贵州,27|四川,28|广东,29|云南,30|广西,31|海南,32|香港,33|澳门,34|台湾</div></pre></td></tr></table></figure>
<p>这是获取到的代码</p>
</li>
<li>解析这段代码获取各个省的编号在<a href="http://m.weather.com.cn/data5/city省编号.xml" target="_blank" rel="external">http://m.weather.com.cn/data5/city省编号.xml</a> 获取该省城市代码。</li>
<li>在<a href="http://m.weather.com.cn/data5/city城市编号.xml" target="_blank" rel="external">http://m.weather.com.cn/data5/city城市编号.xml</a> 获取该城市各个地区的编号</li>
<li><p>最后，在<a href="http://www.weather.com.cn/data/cityinfo/地区编号.html" target="_blank" rel="external">http://www.weather.com.cn/data/cityinfo/地区编号.html</a> 获取这个地区的天气信息，json格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;weatherinfo&quot;:&#123;&quot;city&quot;:&quot;江阴&quot;,&quot;cityid&quot;:&quot;101190202&quot;,&quot;temp1&quot;:&quot;3&quot;,&quot;temp2&quot;:&quot;162&quot;,&quot;weather&quot;:&quot;多云&quot;,&quot;img1&quot;:&quot;n0.gif&quot;,&quot;img2&quot;:&quot;d1.gif&quot;,&quot;ptime&quot;:&quot;18:00&quot;&#125;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>解析这段json，输出</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>基本上没有什么难度。下面是代码：</p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"><span class="keyword">import</span> json</div><div class="line">prov = &#123;&#125;</div><div class="line">city = &#123;&#125;</div><div class="line"><span class="comment">#Read city data</span></div><div class="line">web = urllib2.urlopen(<span class="string">"http://m.weather.com.cn/data5/city.xml"</span>)</div><div class="line">data = web.read()</div><div class="line">web.close()</div><div class="line">l = data.split(<span class="string">","</span>)</div><div class="line"><span class="keyword">for</span> s <span class="keyword">in</span> l:</div><div class="line">    item = s.split(<span class="string">"|"</span>)</div><div class="line">    prov[item[<span class="number">1</span>]] = item[<span class="number">0</span>]</div><div class="line"><span class="keyword">for</span> p <span class="keyword">in</span> prov:</div><div class="line">    i = prov[p]</div><div class="line">    web = urllib2.urlopen(<span class="string">"http://m.weather.com.cn/data5/city%s.xml"</span> % i)</div><div class="line">    data = web.read()</div><div class="line">    <span class="keyword">print</span> data</div><div class="line">    web.close()</div><div class="line">    l = data.split(<span class="string">","</span>)</div><div class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> l:</div><div class="line">        item = s.split(<span class="string">"|"</span>)</div><div class="line">        city[item[<span class="number">1</span>]] = item[<span class="number">0</span>]</div><div class="line"><span class="keyword">for</span> c <span class="keyword">in</span> city:</div><div class="line">    <span class="keyword">print</span> <span class="string">"%s:%s"</span> % (c, city[c])</div><div class="line"></div><div class="line"><span class="comment">#query</span></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Enter city name:"</span></div><div class="line">    c = raw_input()</div><div class="line">    i = city.get(c)</div><div class="line">    <span class="keyword">if</span> i == <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"City not found!"</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    area = &#123; &#125;</div><div class="line">    web = urllib2.urlopen(<span class="string">"http://m.weather.com.cn/data5/city%s.xml"</span> % i)</div><div class="line">    data = web.read()</div><div class="line">    web.close()</div><div class="line">    <span class="keyword">print</span> data</div><div class="line">    l = data.split(<span class="string">","</span>)</div><div class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> l:</div><div class="line">        item = s.split(<span class="string">"|"</span>)</div><div class="line">        area[item[<span class="number">1</span>]] = item[<span class="number">0</span>]</div><div class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> area:</div><div class="line">        <span class="keyword">print</span> <span class="string">"%s:%s"</span> % (a, area[a])</div><div class="line">    <span class="keyword">print</span> <span class="string">"Enter area name:"</span></div><div class="line">    a = raw_input()</div><div class="line">    i = area.get(a)</div><div class="line">    <span class="keyword">if</span> i == <span class="keyword">None</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"Area not found!"</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    web = urllib2.urlopen(<span class="string">"http://m.weather.com.cn/data5/city%s.xml"</span> % i)</div><div class="line">    data = web.read()</div><div class="line">    web.close()</div><div class="line">    item = data.split(<span class="string">"|"</span>)</div><div class="line">    i = item[<span class="number">1</span>]</div><div class="line">    web = urllib2.urlopen(<span class="string">"http://www.weather.com.cn/data/cityinfo/%s.html"</span> % i)</div><div class="line">    data = web.read()</div><div class="line">    root = json.loads(data)</div><div class="line">    info = root[<span class="string">"weatherinfo"</span>];</div><div class="line">    temp = <span class="string">"%s\n%s~%s"</span> % (info[<span class="string">"weather"</span>], info[<span class="string">"temp1"</span>], info[<span class="string">"temp2"</span>])</div><div class="line">    <span class="keyword">print</span> temp</div></pre></td></tr></table></figure>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>代码还有可以改进的地方</p>
<ul>
<li>比如抓取编号之后可以存储在文件中。每次打开检测是否有文件，若存在文件就直接读取文件，若不存在就抓取数据。</li>
<li>这一段代码中有很多重复的地方，可以考虑封装成一个函数，进行代码复用。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python真的非常强大。</p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> urllib2 </tag>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Tarjan]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Tarjan/</url>
      <content type="html"><![CDATA[<h2 id="强连通子图"><a href="#强连通子图" class="headerlink" title="强连通子图"></a>强连通子图</h2><p><code>Tarjan</code>是用以找出 <em>有向图</em> 中强连通子图的算法，那么，什么叫做 <em>强连通子图</em> 呢？</p>
<blockquote>
<p>如果两个顶点可以相互通达，则称两个顶点强连通 <em>(strongly connected)</em> 。如果有向<br>图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分<br>量 <em>(strongly connected components)</em> 。<br>——<a href="http://baike.baidu.com/link?url=6d_TxAkGUvJoZavApHLSyF82lJGH61GOX281z9OOnkoVGuIYQeDl7Q4Wl06axx-Q2q2MeVqxp8bquN6lL4qO5Qf1QUiTEv_Xy9kXXe4aIOC" target="_blank" rel="external">百度百科</a></p>
</blockquote>
<p>总结一下，强连通子图有如下性质：<br>设原图为\(V\)，子图为\(V’\)，那么</p>
<ul>
<li>对于任意\(u \in V’, u \in V\)。这是显然的，子图嘛。</li>
<li>对于任意\(u,v \in V’\)，\(u,v\)之间互相存在通路。换言之，\(u\)可以到达<br>\(v\)，\(v\)也可到达\(u\)。</li>
<li>对于任意\(u \in V, v \notin V\)，\(u,v\)之间不存在互相之间的通路（\(u\)<br>到不了\(v\)，或\(v\)到不了\(u\)）。这是强连通子图的极大性。如果图里的顶点<br>还和在子图外的顶点强连通，为啥不把那个顶点也放进来呢？</li>
<li>一张图可以具有多个强连通子图，并且他们两两不相交。</li>
</ul>
<h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Tarjan算法利用一个栈和递归 <em>(DFS)</em> 的方法，对问题进行求解。<br><a id="more"></a><br>由于算法基于递归 <em>(DFS)</em> ，所以有些地方难于说清楚，那么我们来明确一下每一次递归<br>所作的事情。</p>
<p>每一次递归我们的知道的信息就是需要处理的顶点，还有之前递归所获取的信息。并且，<br>我们知道这个顶点之前一定没有被处理过。</p>
<p>那么，我们要做什么呢？首先，我们把这个顶点压进栈中，再从这个顶点继续向外拓展。如<br>果遇到了一个尚未访问过的顶点，就对它再调用<code>tarjan</code>。如果遇到了已经在栈中的点，那<br>说明这个点与之在同一个强连通子图中。</p>
<p>话说了这么多，究竟怎么求出强连通子图呢？我们知道，强连通子图中必然有一个顶点u是<br>第一个被访问到，也第一个入栈，不妨称为<em>根顶点</em>。当算法经过一步步拓展再次返回到这<br>个顶点时，可以说明这个强连通子图中的所有顶点都访问到了。只要把栈中在根顶点以上<br>包括根顶点的所有顶点弹出，那么这些弹出的顶点就是所求的强连通子图之一。</p>
<p>那怎样判断某个顶点是否是强连通子图的根顶点呢？<strong>我们为每个顶点引入两个值</strong>。</p>
<ul>
<li>index值。表示dfs访问到这个顶点的次序。是递增的。</li>
<li>lowlink值。表示该顶点可到达顶点的最小index值。<em>（也就是该顶点可到达的入栈最早<br>的顶点的index值）</em></li>
</ul>
<p>于是，一切都很简单了。如果栈中的一个顶点是强连通子图的根顶点，那么<code>u.index ==
u.lowlink</code>是必然成立的。因为它自身就是那个最早的顶点了。</p>
<p>那么算法的处理过程就很好说清楚了。为了求得一个顶点的lowlink，我们检查从它出发的<br>每一条边。</p>
<ul>
<li>如果边连接的顶点未被访问过，那么就先对它递归调用，求出他的lowlink，然<br>后与自己的比较，取更小的那一个赋给自己的lowlink。</li>
<li>如果边连接的顶点已经被访问过了。那么进行判断，如果不在栈中，说明并不属于一个<br>强连通子图，不处理。如果在一个栈中，说明处于一个强连通子图中，那么直接将它的low<br>link与自己的lowlink之间更小的一个赋给自己的lowlink。</li>
</ul>
<p>最后，我们对传入的顶点u做一次判断。如果<code>u.index == u.lowlink</code>，说明它是强连通子图<br>的根顶点，我们就可以弹出栈中元素直到这个元素被弹出。</p>
<p>有个小问题，<strong>怎样保证根顶点到栈顶的所有元素都位于同一个强连通子图呢？</strong></p>
<p>其实，dfs的递归调用也形成了一个调用栈。根顶点，设为\(u\)，是dfs最先访问到的，<br>故其调用栈中的元素\(S_u\)必然位于栈下方的位置。若后续dfs到了另一个强连通子图的<br>根顶点，设为\(v\)。执行将\(v\)所属的强连通子图内顶点从栈中弹出的那层dfs必然在<br>调用栈中位于\(S_u\)上方。所以当执行到\(S_u\)时，\(S_v\)已被从调用栈中弹出并<br>完成了它的使命（从栈中弹出元素）。</p>
<p>当然，弹出元素的时候我们还要做一些标记工作，不然不就白忙活了嘛。</p>
<p>时间复杂度：\(O(nm)\)</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void tarjan(int u)</div><div class="line">&#123;</div><div class="line">    d[u] = low[u] = dcnt++;</div><div class="line">    inStack[u] = true;</div><div class="line">    s.push(u);</div><div class="line">    int v;</div><div class="line">    for (int e = head[u]; e != -1; e = edges[e].next) &#123;</div><div class="line">        v = edges[e].to;</div><div class="line">        if (d[v] == -1) &#123;</div><div class="line">            tarjan(v);</div><div class="line">            low[u] = min(low[u], low[v]);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            if (inStack[v]) &#123;</div><div class="line">                low[u] = min(low[u], low[v]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (d[u] == low[u]) &#123;</div><div class="line">        do &#123;</div><div class="line">            v = s.top();</div><div class="line">            s.pop();</div><div class="line">            inStack[v] = false;</div><div class="line">            idx[v] = icnt;</div><div class="line">        &#125; while (v != u);</div><div class="line">        icnt++;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Edmonds Karp]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Edmonds-Karp/</url>
      <content type="html"><![CDATA[<h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>最大流问题，或者说，物资运输问题。你的目标是把物资从一个地方运到另一个地方，你知道所有的站点以及各个中转站之间可以运输的最大物资量。需要求解的是运输物资的最大量。<br><img src="http://linfile.xyz/data/vip_data/f_4268.svg" alt="pic1"></p>
<p>在上面的这一张图\(V\)中，所有顶点都表示一个站点，边表示站点之间的路，边权表示边连接的两个站点之间可以 <strong>运输物资的最大量</strong> 。道路和边一样，都是 <strong>有向的</strong> 。</p>
<p>从0到1最多可以运输多少物资呢？可以轻易的看出，是8个单位。如下图所示：</p>
<p><img src="http://linfile.xyz/data/vip_data/f_1152.svg" alt="pic2"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>熟悉了增广路问题后，让我们对一些量进行符号规定：</p>
<ul>
<li>容量 <em>(capacity)</em> 。对于\(u \in V, v \in V\)，它们之间可以运输的物资最大量（也即边的容量）记为\(c(u,v)\)。若\(u, v\)之间没有边，则\(c(u,v)=0\)</li>
<li>流量 <em>(flow)</em> 。对于\(u \in V, v \in V\)，它们之间已经榆树物资的量（也即边的流量）记为\(f(u,v)\)。<a id="more"></a>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h4>$$f(u,v) \leq c(u, v)$$</li>
</ul>
<p>这是显然的，流量不能大于容量。</p>
<h4 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h4><p>$$f(u,v)=-f(v,u)$$</p>
<p>这也是显而易见的，从A到B运输了8单位就相当于从B到A运输了-8单位。</p>
<h4 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h4><p>对于任意除了起点与终点之外的顶点，流入量都应等于流出量。</p>
<p>由于世界生产力还不够发达，没必要把物资留在中转点而造成浪费:)</p>
<h2 id="Edmonds-Karp"><a href="#Edmonds-Karp" class="headerlink" title="Edmonds-Karp"></a>Edmonds-Karp</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Edmonds-Karp，也称为增广路算法，是求解最大流问题的一个常用算法。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>假设起点是s，终点是t。</p>
<ul>
<li>在图中找出任意的一条s到t的通路。求出这条路可以通过的最大物资量，将这个物资量增加到每条边的流量中。</li>
<li>重复上一步，直到在图中找不到s到t的通路。</li>
</ul>
<p>其中，s到t的通路称为一条 <strong>增广路</strong> ，将增广路的最大流量添加到每条边的流量中的过程称为 <strong>增广</strong>。</p>
<p>看似很简单，但且慢！别忘了，由于每一次增广我们都随便挑选了一条通路，然而我们并不知道我们挑选的路是否在最优解中，如何解决呢？</p>
<p>既然把物资从\(u\)运到\(v\)会增加\(f(u,v)\)那么显然，把物资从v运到u会减小\(f(u,v)\)，这与之前的定义中是一个道理。那么为了得到最优解，虽然只有\(u\)到\(v\)有一条有向边，我们仍然可以把物资从\(v\)运到\(u\)，来获得最优解，因为这样可以调整之前选择的不是那么好的最广路。</p>
<p><strong>反向边</strong></p>
<p>为了便与处理，我们引入 <strong>反向边</strong> 的概念。对于任意一条边\( e=(u,v) \)，加入它的反向边\( e’ = (v,u) \)，并且满足：\(f(e’)=0, c(e’)=0\)。在算法中我们对边和反向边一视同仁，都只要满足上面提到的三条性质就行了，虽然，反向边的\(c\)是一个负数。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在算法中，我们使用<code>BFS</code>找出s到t的通路，并求出这条通路的最大流量\(\Delta f\)。</p>
<p>那么，\(\Delta f\)怎么求呢？</p>
<p>用 <strong>递推</strong> 的方法：引入一个数组a[u]，表示s到u通路的最大流量。当顶点u从边e到达顶点v时，<code>a[v] = min(a[u], e.cap - e.flow)</code>。那么，\(\Delta f\)就等于a[t]。</p>
<p>求出\(\Delta f\)后，递归这条路上的每一条边\(e\)，设\(e=(u,v)\)，那么</p>
<p>$$f_{u,v}=f(u,v) + \Delta f$$</p>
<p>$$f_{v,u}=f(v,u) - \Delta f$$</p>
<p>并且将\(\Delta f\)计入总流量</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">int maxFlow(int s, int t)</div><div class="line">&#123;</div><div class="line">    int flow = 0;</div><div class="line">    while (true) &#123;</div><div class="line">        memset(a, 0, sizeof a);</div><div class="line">        queue&lt;int&gt; q;</div><div class="line">        q.push(s);</div><div class="line">        a[s] = INF;</div><div class="line">        while (!q.empty()) &#123;</div><div class="line">            int x = q.front(); q.pop();</div><div class="line">            for (int e = head[x]; e != -1; e = edges[e].next) &#123;</div><div class="line">                Edge&amp; ed = edges[e];</div><div class="line">                if (!a[ed.to] &amp;&amp; ed.cap &gt; ed.flow) &#123;</div><div class="line">                    p[ed.to] = e;</div><div class="line">                    a[ed.to] = min(a[x], ed.cap - ed.flow);</div><div class="line">                    q.push(ed.to);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (a[t]) break;</div><div class="line">        &#125;</div><div class="line">        if (!a[t]) break;</div><div class="line">        for (int u = t; u != s; u = edges[p[u]].from) &#123;</div><div class="line">            edges[p[u]].flow += a[t];</div><div class="line">            edges[p[u] ^ 1].flow -= a[t];</div><div class="line">        &#125;</div><div class="line">        flow += a[t];</div><div class="line">    &#125;</div><div class="line">    return flow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>由于边和反向边在数组edges中序号紧邻（(0,1), (2,3)…)，且一个为奇数，一个为偶数。故，若边（或反向边）的序号为i，i^1就是反向边（或边）的序号。（^为异或运算符）</em></p>
<h4 id="添加边与反向边"><a href="#添加边与反向边" class="headerlink" title="添加边与反向边"></a>添加边与反向边</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void append(int u, int v, int cap)</div><div class="line">&#123;</div><div class="line">    Edge e;</div><div class="line">    e.from = u;</div><div class="line">    e.to = v;</div><div class="line">    e.cap = cap;</div><div class="line">    e.flow = 0;</div><div class="line">    e.next = head[u];</div><div class="line">    head[u] = cnt;</div><div class="line">    edges[cnt++] = e;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void addEdge(int u, int v, int cap)</div><div class="line">&#123;</div><div class="line">    append(u, v, cap);</div><div class="line">    append(v, u, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看看一开始的那张图所得到的解，经过处理后是这样的：<br><img src="http://linfile.xyz/data/vip_data/f_6249.svg" alt="img"><br>其中，红色的边表示不能通过（容量满）。s到t已经没有通路了。</p>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dijstra]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Dijstra/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里的文章大多都是看了刘汝佳大大的《算法竞赛入门经典》之后写的，差不多就是把其内容复述一遍。一些我<strong>难以理解，经过思考</strong>的内容也会写出。</p>
<p>进入正题。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Dijstra是图论中用以求解单源最短路径<em>(也就是一个顶点到图中其他顶点的最短路径)</em> 的算法。</p>
<p>时间复杂度为O(n^2)。<br><a id="more"></a></p>
<h1 id="原理方法"><a href="#原理方法" class="headerlink" title="原理方法"></a>原理方法</h1><ul>
<li>初始化<ul>
<li>将表示距离的数组d全部初始化成一个极大的值(称为INF)，将要求解的顶点的d[u]设为0</li>
<li>将表示是否访问过的数组vis全部设为0。这里不要将要求解的顶点的vis值单独设置。</li>
</ul>
</li>
<li>处理<ul>
<li>在所有顶点中，遍历选择一个顶点，这个顶点满足如下条件。<ul>
<li>这个顶点的d值最小</li>
<li>这个顶点被访问过，也就是<code>d[v] &lt; INF</code></li>
<li>这个顶点没有被处理过，也就是<code>vis[v] != 1</code></li>
</ul>
</li>
<li>处理这个上一步选择的顶点u。遍历这个顶点指向的所有顶点v。若<code>d[v] &gt; d[u] + w[u, v]</code>，则更新d[v]，<code>d[v] = d[u] + w[u, v]</code></li>
<li>将上述步骤重复(n-1)次</li>
</ul>
</li>
</ul>
<p><strong>为什么重复(n-1)次呢？</strong></p>
<p>因为在n个顶点的图中，某个顶点到另一个顶点的<strong>最短路最长也只有(n-1)条边</strong>。</p>
<p>因为(n-1)条边正好经过n个顶点，若大于(n-1)条边，那么必然重复经过了某个顶点，即存在环。去掉环，所得结果不会更差。</p>
<p><img src="http://linfile.xyz/data/vip_data/f_9145.jpg" alt="f_9145.jpg"></p>
<p>如图展示了一个含有四个顶点的图，其中1到4的最短路经过了4个顶点，3条边。</p>
<p>那么，回到原问题，<strong>为什么重复(n-1)次呢？</strong></p>
<p>假设要求解的顶点是u，对于一个顶点v，假设u和v之间的最短路经过了d条边。那么每一轮重复，这条最短路都会向前拓展一条边。所以要求解出这条最短路需要重复d次。而经过上面的证明，图中最长的最短路最多只经过(n-1)条边，所以重复(n-1)次，就可以求出所有最短路了。</p>
<p><em>下面用图片演示，便于理解。</em></p>
<p><img src="http://linfile.xyz/data/vip_data/f_3504.jpg" alt="f_3504.jpg"></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void dijstra(int u)</div><div class="line">&#123;</div><div class="line">    memset(vis, 0, sizeof vis);</div><div class="line">    const int INF = 2 &lt;&lt; 30;</div><div class="line">    for (int i = 0; i &lt; n; i++)</div><div class="line">        d[i] = INF;</div><div class="line">    d[u] = 0;</div><div class="line">    for (int k = 1; k &lt; n; k++) &#123; //repeat n-1 times</div><div class="line">        int v;</div><div class="line">        int minw = INF;</div><div class="line">        for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">            if (d[i] &lt; minw &amp;&amp; !vis[i]) &#123;</div><div class="line">                v = i;</div><div class="line">                minw = d[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        vis[v] = 1;</div><div class="line">        for (int ed = head[v]; ed != -1; ed = edges[ed].next) &#123;</div><div class="line">            Edge ee = edges[ed];</div><div class="line">            d[ee.to] = min(d[ee.to], d[v] + ee.w);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在图论中，还是<code>SPFA</code>用的多。</p>
<h1 id="顺带一提"><a href="#顺带一提" class="headerlink" title="顺带一提"></a>顺带一提</h1><p>代码都在 <a href="https://github.com/Linyxus/algorithms" target="_blank" rel="external">Github</a> 上。</p>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SPFA]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/SPFA/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>SPFA</code>是基于<code>Bellman-ford</code>的<strong>队列优化</strong>。一般来说，SPFA的速度快于<code>dijstra</code>和<code>Bellman-ford</code>，是图论中常用的一种算法。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>算法从源点出发，向外拓展，若一个顶点的最小距离值被更新了，就将他放入队列中等待处理，因为这个顶点最小距离的减少可能会造成<strong>其他顶点的最短距离也减小</strong>。</p>
<p>时间复杂度为\(O(k|E|)\) 。其中，\(k\)为每条边被处理的平均次数，而\(E\)是边集。<br><a id="more"></a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>初始化</li>
<li>将源点放入队列中</li>
<li>取出队列中的一个顶点，检查它可以到达的所有顶点。假设v是u可以到达的一个顶点。若<code>d[ed.to] &gt; d[u] + ed.w</code>，那么<code>d[ed.to] = d[u] + ed.w</code>。并且，若v不在队列中，就将v放入队列。</li>
<li>重复上一步，直到队列为空。</li>
</ul>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><ul>
<li>上面在将顶点放入队列之前，会检查它是否已经在队列之中。目的是为了优化算法运行速度。将顶点放入队列的目的是检查它可以到达的顶点的最短距离值是否可以更小，既然顶点已经在队列中，那么再放入一次将没有意义。</li>
<li>为了检测负环图，可以增加一个数组，记录顶点被放入队列的次数。若发现它被放入队列的次数超过了n次，那么，<strong>必然存在负环</strong>。<strong><em>这是为什么呢？</em></strong> 考虑顶点被放入队列的原因，是因为源点到该顶点之间出现了一条更短的道路。那么考虑一个极端的情况，一条最短路的每一次延伸的导致源点到该顶点出现了一条更短的道路:<br><img src="http://linfile.xyz/data/vip_data/f_6386.svg" alt="spfa1"><br>可以看到，这张图中，最长的最短路径经过了5个顶点，且每一次拓展都会使一个顶点的最短距离值变得更小，被放入队列。而即便如此，它也顶多被放入队列5次——不，甚至更少，因为这条最短路的终点就是他本身，并不会将自己放入最短路，因而这个顶点最多被放入4次。<strong>故，当一个顶点被放入队列超过n次，这张图中是必然存负圈的。</strong><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">bool spfa(int s)</div><div class="line">&#123;</div><div class="line">    queue&lt;int&gt; q;</div><div class="line">    memset(inq, 0, sizeof inq);</div><div class="line">    memset(rcnt, 0, sizeof rcnt);</div><div class="line">    for (int i = 0; i &lt; n; i++) &#123;</div><div class="line">        d[i] = INF;</div><div class="line">        p[i] = i;</div><div class="line">    &#125;</div><div class="line">    d[s] = 0;</div><div class="line">    inq[s] = true;</div><div class="line">    q.push(s);</div><div class="line">    while (!q.empty()) &#123;</div><div class="line">        int u = q.front(); q.pop();</div><div class="line">        inq[u] = false;</div><div class="line">        for (int e = head[u]; e != -1; e = edges[e].next) &#123;</div><div class="line">            Edge ed = edges[e];</div><div class="line">            if (d[ed.to] &gt; d[u] + ed.w) &#123;</div><div class="line">                d[ed.to] = d[u] + ed.w;</div><div class="line">                p[ed.to] = u;</div><div class="line">                if (!inq[ed.to]) &#123;</div><div class="line">                    q.push(ed.to);</div><div class="line">                    inq[ed.to] = true;</div><div class="line">                    if (++rcnt[ed.to] &gt; n)</div><div class="line">                        return false;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><em>完整代码见 <a href="https://github.com/Linyxus/algorithms" target="_blank" rel="external">Github</a></em></p>
<h2 id="探究"><a href="#探究" class="headerlink" title="探究"></a>探究</h2><p><em>《算法竞赛入门经典》p364</em> 刘汝佳大大留下了一个问题：</p>
<blockquote>
<p>另外，如果图中有其他负圈但是s无法到达这个负圈，则上面的算法也无法找到。</p>
</blockquote>
<p>他给了一个提示：增加一个顶点。</p>
<p>解决方法很简单，增加一个连通源点与其他所有顶点的顶点，且边权为0，即可。</p>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kruskal]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Kruskal/</url>
      <content type="html"><![CDATA[<p>Kruskal</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Kruskal算法用于求无向图的最小生成树。时间复杂度为O(nlogn)。</p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p><code>贪心法</code></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>将所有边按权值大小排序</li>
<li>用一个边集E表示选择了的边。清空这个边集。</li>
<li>按照权值从小到大的顺序依次考虑每条边。<ul>
<li>若将这条边放入E中，不产生环，就将这条边放入E中。</li>
<li>反之，不放入。</li>
</ul>
</li>
<li>考虑完每一条边后，E就是所求的最小生成树。<a id="more"></a>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3>为什么若存在环，就不选择这条边呢？</li>
</ul>
<p>考虑一个<strong>存在环</strong>的生成树V。在这个环中，若去掉一条权值最大的边，那么这个环包含的节点仍然是连通的，且如此得到的生成树V1不会比原生成树V差。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>那么，怎样判断某条边加入后是否会产生环呢？<strong><em>只要这条边连接的两个顶点u,v连通</em></strong>，那么这条边的加入就会产生环。因为u,v之间本来就有一条通路，加入该边之后将产生两条，也就形成环了。</p>
<p>怎样判断两条边是否连通呢？</p>
<p>使用连通分量不易于合并，有一种方便高效的方法叫做<code>并查集</code>。</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p><img src="http://linfile.xyz/data/vip_data/f_4525.jpg" alt="f_4525.jpg"></p>
<p>并查集将顶点以树的方式组织。所有连通的顶点形成一棵树，这棵树的树根称为这组顶点的<code>代表元</code>。判断两个顶点是否连通只要分别找到他们的树根（也就是代表元），比较是否相同。合并的方法也很简单，只要将某一组连通顶点的代表元的父亲设为另一组连通顶点的代表元即可。</p>
<p><img src="http://linfile.xyz/data/vip_data/f_6234.jpg" alt="f_6234.jpg"></p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><p>递归找到树根（代表元）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化时将所有p[u]设为u自身</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> p[u]==u? u : find(p[u]); &#125;</div></pre></td></tr></table></figure></p>
<p>但是有一个问题，如果树退化成一条链，那么每次寻找都要遍历一次树，速度很慢。</p>
<p>解决方法很简单，每次找到树根之后把u直接连接到树根即可。但代码相应复杂了一些。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(u)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> v = p[u];</div><div class="line">    <span class="keyword">while</span> (v != p[v]) &#123;</div><div class="line">        v = p[v];</div><div class="line">    &#125;</div><div class="line">    p[u] = v;</div><div class="line">    <span class="keyword">return</span> v;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://linfile.xyz/data/vip_data/f_9506.jpg" alt="f_9506.jpg"></p>
<h5 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h5><p>合并的方法很简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//合并u,v所在的树</span></div><div class="line"><span class="keyword">int</span> pu = find(u);</div><div class="line"><span class="keyword">int</span> pv = find(v);</div><div class="line">p[pu] = pv; <span class="comment">//p[pv] = pu;也一样</span></div></pre></td></tr></table></figure></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>解决了上面的难点，终于可以写出代码了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> eu[maxe], ev[maxe], ew[maxe]; <span class="comment">// 表示边连接的两个顶点以及权值</span></div><div class="line"><span class="keyword">int</span> que[maxe]; <span class="comment">//排序</span></div><div class="line"><span class="keyword">int</span> sel[maxe]; <span class="comment">//是否选择了这条边</span></div><div class="line"><span class="keyword">int</span> p[maxn]; <span class="comment">//并查集</span></div><div class="line"><span class="keyword">int</span> n; <span class="comment">//顶点数</span></div><div class="line"><span class="keyword">int</span> e; <span class="comment">//边数</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">memset</span>(sel, <span class="number">0</span>, <span class="keyword">sizeof</span> sel); <span class="comment">//清空选择的边集</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">        p[i] = i; <span class="comment">//初始化p数组</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</div><div class="line">        que[i] = i; <span class="comment">//主要是为了方便排序</span></div><div class="line">    &#125;</div><div class="line">    sort(que, que + e, [](<span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123; <span class="keyword">return</span> ew[que[l]] &lt; ew[que[r]]; &#125;);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</div><div class="line">        <span class="keyword">int</span> k = que[i];</div><div class="line">        <span class="keyword">int</span> uroot = find(eu[k]);</div><div class="line">        <span class="keyword">int</span> vroot = find(ev[k]);</div><div class="line">        <span class="keyword">if</span> (uroot != vroot) &#123;</div><div class="line">            sel[k] = <span class="number">1</span>;</div><div class="line">            p[uroot] = vroot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Kruskal的时间复杂度主要制约在于排序。由于使用了并查集，连通的判断与合并是非常快的，几乎可以看做常数时间。</p>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 图论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[快速读取整数]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/%E5%BF%AB%E9%80%9F%E8%AF%BB%E5%8F%96%E6%95%B4%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>可能大家都知道，在读数据的时候，<code>scanf</code>较之<code>cin</code>快上很多。但当某些题目数据量达到<strong>百万</strong>级别，就算使用scanf也太慢了。一共一秒钟的时间，读取数据都要用去大半。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>当读取整数时，我们可以手动的读取字符，组成数字。这样速度将有巨大的提升。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>&lt;cstdio&gt;</code>库中有一个<code>readchar()</code>函数，读入一个字符，速度非常快。</p>
<p>我们将利用这一点快速的手动读入整数。</p>
<p>由于原理很简单，不多做阐述。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">unsigned_qread</span><span class="params">(<span class="keyword">int</span>&amp; d)</span></span></div><div class="line">&#123;</div><div class="line">    d = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> ch = getchar();</div><div class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)</div><div class="line">        ch = getchar();</div><div class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</div><div class="line">        d = d * <span class="number">10</span> + ch - <span class="string">'0'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h3><p>只可以读取<strong>正整数</strong>，不过已经可以满足大部分使用的需要了。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>我写了一段代码测试比较<code>scanf</code>，<code>cin</code>，<code>qread</code>的速度。</p>
<p><img src="http://linfile.xyz/data/vip_data/f_3146.png" alt="f_3146.png"></p>
<p>可以看到，手动读取整数比其他两种快得多。通过这个方法，可以有效的避免数据量大的题目由于读取数据而造成的TLE。<br><code>``&gt;)
}&lt;/cstdio&gt;</code></p>
]]></content>
      
        <categories>
            
            <category> Noip </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> other </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Hexo/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-Test"><a href="#Hexo-Test" class="headerlink" title="Hexo Test"></a>Hexo Test</h1><h2 id="Quote"><a href="#Quote" class="headerlink" title="Quote"></a>Quote</h2><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight plain"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div></pre></td></tr></table></figure>
<h2 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a><del>Gist</del></h2><p>Gist服务不稳定。</p>
]]></content>
      
        <categories>
            
            <category> 0 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hello </tag>
            
            <tag> test </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://linyxus.xyz/blog/blog/2017/03/04/Hello-Hexo/</url>
      <content type="html"><![CDATA[<h2 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo!"></a>Hello Hexo!</h2><p>终于装好了<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>，和WP和Typecho比起来，Hexo深得我心0v0</p>
<p>静态网页带来的速度不用说，插件主题的丰富程度也是不错的。</p>
<p>但是之前Typecho上的数据还没迁移过来0v0所以现在一片空白。</p>
<p><del>测试一下Gist看看0v0</del></p>
<p>算了不试了，好卡啊。ww</p>
<h2 id="有点问题"><a href="#有点问题" class="headerlink" title="有点问题"></a>有点问题</h2><p><a href="https://disqus.com" target="_blank" rel="external">Disqus</a>不翻墙上不了？</p>
<p><a href="https://github.com" target="_blank" rel="external">Github</a>在我写文章的时候又挂了。。怪不得刚刚用Gist卡住了。</p>
<p>Wait…现在上Github又要翻墙了？简直…</p>
<h2 id="正经的话"><a href="#正经的话" class="headerlink" title="正经的话"></a>正经的话</h2><p>感觉折腾博客系统占用的时间甚至多于看书看NOIP复习小四门的时间了0v0关键是<br>折腾完了其实也没有人看…(哭)</p>
<p>这次整完Hexo肯定不换新的了0v0</p>
<p><strong>最后祝自己小四门4A2333333</strong></p>
]]></content>
      
        <categories>
            
            <category> 0 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hello </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
