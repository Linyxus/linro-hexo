{"pages":[{"title":"About","permalink":"http://linyxus.xyz/blog/about/index.html","text":"Me苦逼高中狗一枚，学习真的很忙，周末有空会折腾折腾电脑。 参加过Noip，并且下次仍然要参加，然而还是很菜。 喜欢C++，QML大法好。 最近在看机器学习。 Blog会写一些Noip的学习笔记，因为还很菜所以都很基础。还会写折腾一些东西的过程。（我折腾的时间比安安稳稳写代码学习的时间还长我会乱说？） 当然也想写一点小脑洞。23333 InfoHexo基于npm的静态博客系统。这就是用它搭的。 MaterialFlow主题。Material Design"}],"posts":[{"title":"Python查询天气","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Python查询天气/","text":"使用Python制作天气查询程序前言原教程地址：Crossin 这篇文章是我按照上面的教程学习后写的一篇笔记，由于我是Python初学者，如有不对的地方欢迎指出哦0v0 截图 原理利用了中国天气网的API。 首先，在http://m.weather.com.cn/data5/city.xml 获取各个省的编号 101|北京,02|上海,03|天津,04|重庆,05|黑龙江,06|吉林,07|辽宁,08|内蒙古,09|河北,10|山西,11|陕西,12|山东,13|新疆,14|西藏,15|青海,16|甘肃,17|宁夏,18|河南,19|江苏,20|湖北,21|浙江,22|安徽,23|福建,24|江西,25|湖南,26|贵州,27|四川,28|广东,29|云南,30|广西,31|海南,32|香港,33|澳门,34|台湾 这是获取到的代码 解析这段代码获取各个省的编号在http://m.weather.com.cn/data5/city省编号.xml 获取该省城市代码。 在http://m.weather.com.cn/data5/city城市编号.xml 获取该城市各个地区的编号 最后，在http://www.weather.com.cn/data/cityinfo/地区编号.html 获取这个地区的天气信息，json格式 1&#123;&quot;weatherinfo&quot;:&#123;&quot;city&quot;:&quot;江阴&quot;,&quot;cityid&quot;:&quot;101190202&quot;,&quot;temp1&quot;:&quot;3&quot;,&quot;temp2&quot;:&quot;162&quot;,&quot;weather&quot;:&quot;多云&quot;,&quot;img1&quot;:&quot;n0.gif&quot;,&quot;img2&quot;:&quot;d1.gif&quot;,&quot;ptime&quot;:&quot;18:00&quot;&#125;&#125; 解析这段json，输出 实现基本上没有什么难度。下面是代码： 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import urllib2import jsonprov = &#123;&#125;city = &#123;&#125;#Read city dataweb = urllib2.urlopen(\"http://m.weather.com.cn/data5/city.xml\")data = web.read()web.close()l = data.split(\",\")for s in l: item = s.split(\"|\") prov[item[1]] = item[0]for p in prov: i = prov[p] web = urllib2.urlopen(\"http://m.weather.com.cn/data5/city%s.xml\" % i) data = web.read() print data web.close() l = data.split(\",\") for s in l: item = s.split(\"|\") city[item[1]] = item[0]for c in city: print \"%s:%s\" % (c, city[c])#querywhile True: print \"Enter city name:\" c = raw_input() i = city.get(c) if i == None: print \"City not found!\" continue area = &#123; &#125; web = urllib2.urlopen(\"http://m.weather.com.cn/data5/city%s.xml\" % i) data = web.read() web.close() print data l = data.split(\",\") for s in l: item = s.split(\"|\") area[item[1]] = item[0] for a in area: print \"%s:%s\" % (a, area[a]) print \"Enter area name:\" a = raw_input() i = area.get(a) if i == None: print \"Area not found!\" continue web = urllib2.urlopen(\"http://m.weather.com.cn/data5/city%s.xml\" % i) data = web.read() web.close() item = data.split(\"|\") i = item[1] web = urllib2.urlopen(\"http://www.weather.com.cn/data/cityinfo/%s.html\" % i) data = web.read() root = json.loads(data) info = root[\"weatherinfo\"]; temp = \"%s\\n%s~%s\" % (info[\"weather\"], info[\"temp1\"], info[\"temp2\"]) print temp 改进代码还有可以改进的地方 比如抓取编号之后可以存储在文件中。每次打开检测是否有文件，若存在文件就直接读取文件，若不存在就抓取数据。 这一段代码中有很多重复的地方，可以考虑封装成一个函数，进行代码复用。 总结Python真的非常强大。"},{"title":"Tarjan","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Tarjan/","text":"强连通子图Tarjan是用以找出 有向图 中强连通子图的算法，那么，什么叫做 强连通子图 呢？ 如果两个顶点可以相互通达，则称两个顶点强连通 (strongly connected) 。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量 (strongly connected components) 。——百度百科 总结一下，强连通子图有如下性质：设原图为\\(V\\)，子图为\\(V’\\)，那么 对于任意\\(u \\in V’, u \\in V\\)。这是显然的，子图嘛。 对于任意\\(u,v \\in V’\\)，\\(u,v\\)之间互相存在通路。换言之，\\(u\\)可以到达\\(v\\)，\\(v\\)也可到达\\(u\\)。 对于任意\\(u \\in V, v \\notin V\\)，\\(u,v\\)之间不存在互相之间的通路（\\(u\\)到不了\\(v\\)，或\\(v\\)到不了\\(u\\)）。这是强连通子图的极大性。如果图里的顶点还和在子图外的顶点强连通，为啥不把那个顶点也放进来呢？ 一张图可以具有多个强连通子图，并且他们两两不相交。 Tarjan原理Tarjan算法利用一个栈和递归 (DFS) 的方法，对问题进行求解。由于算法基于递归 (DFS) ，所以有些地方难于说清楚，那么我们来明确一下每一次递归所作的事情。 每一次递归我们的知道的信息就是需要处理的顶点，还有之前递归所获取的信息。并且，我们知道这个顶点之前一定没有被处理过。 那么，我们要做什么呢？首先，我们把这个顶点压进栈中，再从这个顶点继续向外拓展。如果遇到了一个尚未访问过的顶点，就对它再调用tarjan。如果遇到了已经在栈中的点，那说明这个点与之在同一个强连通子图中。 话说了这么多，究竟怎么求出强连通子图呢？我们知道，强连通子图中必然有一个顶点u是第一个被访问到，也第一个入栈，不妨称为根顶点。当算法经过一步步拓展再次返回到这个顶点时，可以说明这个强连通子图中的所有顶点都访问到了。只要把栈中在根顶点以上包括根顶点的所有顶点弹出，那么这些弹出的顶点就是所求的强连通子图之一。 那怎样判断某个顶点是否是强连通子图的根顶点呢？我们为每个顶点引入两个值。 index值。表示dfs访问到这个顶点的次序。是递增的。 lowlink值。表示该顶点可到达顶点的最小index值。（也就是该顶点可到达的入栈最早的顶点的index值） 于是，一切都很简单了。如果栈中的一个顶点是强连通子图的根顶点，那么u.index == u.lowlink是必然成立的。因为它自身就是那个最早的顶点了。 那么算法的处理过程就很好说清楚了。为了求得一个顶点的lowlink，我们检查从它出发的每一条边。 如果边连接的顶点未被访问过，那么就先对它递归调用，求出他的lowlink，然后与自己的比较，取更小的那一个赋给自己的lowlink。 如果边连接的顶点已经被访问过了。那么进行判断，如果不在栈中，说明并不属于一个强连通子图，不处理。如果在一个栈中，说明处于一个强连通子图中，那么直接将它的lowlink与自己的lowlink之间更小的一个赋给自己的lowlink。 最后，我们对传入的顶点u做一次判断。如果u.index == u.lowlink，说明它是强连通子图的根顶点，我们就可以弹出栈中元素直到这个元素被弹出。 有个小问题，怎样保证根顶点到栈顶的所有元素都位于同一个强连通子图呢？ 其实，dfs的递归调用也形成了一个调用栈。根顶点，设为\\(u\\)，是dfs最先访问到的，故其调用栈中的元素\\(S_u\\)必然位于栈下方的位置。若后续dfs到了另一个强连通子图的根顶点，设为\\(v\\)。执行将\\(v\\)所属的强连通子图内顶点从栈中弹出的那层dfs必然在调用栈中位于\\(S_u\\)上方。所以当执行到\\(S_u\\)时，\\(S_v\\)已被从调用栈中弹出并完成了它的使命（从栈中弹出元素）。 当然，弹出元素的时候我们还要做一些标记工作，不然不就白忙活了嘛。 时间复杂度：\\(O(nm)\\) 实现12345678910111213141516171819202122232425262728void tarjan(int u)&#123; d[u] = low[u] = dcnt++; inStack[u] = true; s.push(u); int v; for (int e = head[u]; e != -1; e = edges[e].next) &#123; v = edges[e].to; if (d[v] == -1) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else &#123; if (inStack[v]) &#123; low[u] = min(low[u], low[v]); &#125; &#125; &#125; if (d[u] == low[u]) &#123; do &#123; v = s.top(); s.pop(); inStack[v] = false; idx[v] = icnt; &#125; while (v != u); icnt++; &#125;&#125;"},{"title":"Edmonds Karp","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Edmonds-Karp/","text":"最大流问题例子最大流问题，或者说，物资运输问题。你的目标是把物资从一个地方运到另一个地方，你知道所有的站点以及各个中转站之间可以运输的最大物资量。需要求解的是运输物资的最大量。 在上面的这一张图\\(V\\)中，所有顶点都表示一个站点，边表示站点之间的路，边权表示边连接的两个站点之间可以 运输物资的最大量 。道路和边一样，都是 有向的 。 从0到1最多可以运输多少物资呢？可以轻易的看出，是8个单位。如下图所示： 定义熟悉了增广路问题后，让我们对一些量进行符号规定： 容量 (capacity) 。对于\\(u \\in V, v \\in V\\)，它们之间可以运输的物资最大量（也即边的容量）记为\\(c(u,v)\\)。若\\(u, v\\)之间没有边，则\\(c(u,v)=0\\) 流量 (flow) 。对于\\(u \\in V, v \\in V\\)，它们之间已经榆树物资的量（也即边的流量）记为\\(f(u,v)\\)。 性质性质一$$f(u,v) \\leq c(u, v)$$ 这是显然的，流量不能大于容量。 性质二$$f(u,v)=-f(v,u)$$ 这也是显而易见的，从A到B运输了8单位就相当于从B到A运输了-8单位。 性质三对于任意除了起点与终点之外的顶点，流入量都应等于流出量。 由于世界生产力还不够发达，没必要把物资留在中转点而造成浪费:) Edmonds-Karp介绍Edmonds-Karp，也称为增广路算法，是求解最大流问题的一个常用算法。 原理假设起点是s，终点是t。 在图中找出任意的一条s到t的通路。求出这条路可以通过的最大物资量，将这个物资量增加到每条边的流量中。 重复上一步，直到在图中找不到s到t的通路。 其中，s到t的通路称为一条 增广路 ，将增广路的最大流量添加到每条边的流量中的过程称为 增广。 看似很简单，但且慢！别忘了，由于每一次增广我们都随便挑选了一条通路，然而我们并不知道我们挑选的路是否在最优解中，如何解决呢？ 既然把物资从\\(u\\)运到\\(v\\)会增加\\(f(u,v)\\)那么显然，把物资从v运到u会减小\\(f(u,v)\\)，这与之前的定义中是一个道理。那么为了得到最优解，虽然只有\\(u\\)到\\(v\\)有一条有向边，我们仍然可以把物资从\\(v\\)运到\\(u\\)，来获得最优解，因为这样可以调整之前选择的不是那么好的最广路。 反向边 为了便与处理，我们引入 反向边 的概念。对于任意一条边\\( e=(u,v) \\)，加入它的反向边\\( e’ = (v,u) \\)，并且满足：\\(f(e’)=0, c(e’)=0\\)。在算法中我们对边和反向边一视同仁，都只要满足上面提到的三条性质就行了，虽然，反向边的\\(c\\)是一个负数。 实现在算法中，我们使用BFS找出s到t的通路，并求出这条通路的最大流量\\(\\Delta f\\)。 那么，\\(\\Delta f\\)怎么求呢？ 用 递推 的方法：引入一个数组a[u]，表示s到u通路的最大流量。当顶点u从边e到达顶点v时，a[v] = min(a[u], e.cap - e.flow)。那么，\\(\\Delta f\\)就等于a[t]。 求出\\(\\Delta f\\)后，递归这条路上的每一条边\\(e\\)，设\\(e=(u,v)\\)，那么 $$f_{u,v}=f(u,v) + \\Delta f$$ $$f_{v,u}=f(v,u) - \\Delta f$$ 并且将\\(\\Delta f\\)计入总流量 代码主体1234567891011121314151617181920212223242526272829int maxFlow(int s, int t)&#123; int flow = 0; while (true) &#123; memset(a, 0, sizeof a); queue&lt;int&gt; q; q.push(s); a[s] = INF; while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int e = head[x]; e != -1; e = edges[e].next) &#123; Edge&amp; ed = edges[e]; if (!a[ed.to] &amp;&amp; ed.cap &gt; ed.flow) &#123; p[ed.to] = e; a[ed.to] = min(a[x], ed.cap - ed.flow); q.push(ed.to); &#125; &#125; if (a[t]) break; &#125; if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) &#123; edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; &#125; flow += a[t]; &#125; return flow;&#125; 由于边和反向边在数组edges中序号紧邻（(0,1), (2,3)…)，且一个为奇数，一个为偶数。故，若边（或反向边）的序号为i，i^1就是反向边（或边）的序号。（^为异或运算符） 添加边与反向边1234567891011121314151617void append(int u, int v, int cap)&#123; Edge e; e.from = u; e.to = v; e.cap = cap; e.flow = 0; e.next = head[u]; head[u] = cnt; edges[cnt++] = e;&#125;void addEdge(int u, int v, int cap)&#123; append(u, v, cap); append(v, u, 0);&#125; 看看一开始的那张图所得到的解，经过处理后是这样的：其中，红色的边表示不能通过（容量满）。s到t已经没有通路了。"},{"title":"Dijstra","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Dijstra/","text":"前言这里的文章大多都是看了刘汝佳大大的《算法竞赛入门经典》之后写的，差不多就是把其内容复述一遍。一些我难以理解，经过思考的内容也会写出。 进入正题。 介绍Dijstra是图论中用以求解单源最短路径(也就是一个顶点到图中其他顶点的最短路径) 的算法。 时间复杂度为O(n^2)。 原理方法 初始化 将表示距离的数组d全部初始化成一个极大的值(称为INF)，将要求解的顶点的d[u]设为0 将表示是否访问过的数组vis全部设为0。这里不要将要求解的顶点的vis值单独设置。 处理 在所有顶点中，遍历选择一个顶点，这个顶点满足如下条件。 这个顶点的d值最小 这个顶点被访问过，也就是d[v] &lt; INF 这个顶点没有被处理过，也就是vis[v] != 1 处理这个上一步选择的顶点u。遍历这个顶点指向的所有顶点v。若d[v] &gt; d[u] + w[u, v]，则更新d[v]，d[v] = d[u] + w[u, v] 将上述步骤重复(n-1)次 为什么重复(n-1)次呢？ 因为在n个顶点的图中，某个顶点到另一个顶点的最短路最长也只有(n-1)条边。 因为(n-1)条边正好经过n个顶点，若大于(n-1)条边，那么必然重复经过了某个顶点，即存在环。去掉环，所得结果不会更差。 如图展示了一个含有四个顶点的图，其中1到4的最短路经过了4个顶点，3条边。 那么，回到原问题，为什么重复(n-1)次呢？ 假设要求解的顶点是u，对于一个顶点v，假设u和v之间的最短路经过了d条边。那么每一轮重复，这条最短路都会向前拓展一条边。所以要求解出这条最短路需要重复d次。而经过上面的证明，图中最长的最短路最多只经过(n-1)条边，所以重复(n-1)次，就可以求出所有最短路了。 下面用图片演示，便于理解。 实现1234567891011121314151617181920212223void dijstra(int u)&#123; memset(vis, 0, sizeof vis); const int INF = 2 &lt;&lt; 30; for (int i = 0; i &lt; n; i++) d[i] = INF; d[u] = 0; for (int k = 1; k &lt; n; k++) &#123; //repeat n-1 times int v; int minw = INF; for (int i = 0; i &lt; n; i++) &#123; if (d[i] &lt; minw &amp;&amp; !vis[i]) &#123; v = i; minw = d[i]; &#125; &#125; vis[v] = 1; for (int ed = head[v]; ed != -1; ed = edges[ed].next) &#123; Edge ee = edges[ed]; d[ee.to] = min(d[ee.to], d[v] + ee.w); &#125; &#125;&#125; 总结其实在图论中，还是SPFA用的多。 顺带一提代码都在 Github 上。"},{"title":"SPFA","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/SPFA/","text":"介绍SPFA是基于Bellman-ford的队列优化。一般来说，SPFA的速度快于dijstra和Bellman-ford，是图论中常用的一种算法。 原理算法从源点出发，向外拓展，若一个顶点的最小距离值被更新了，就将他放入队列中等待处理，因为这个顶点最小距离的减少可能会造成其他顶点的最短距离也减小。 时间复杂度为\\(O(k|E|)\\) 。其中，\\(k\\)为每条边被处理的平均次数，而\\(E\\)是边集。 步骤 初始化 将源点放入队列中 取出队列中的一个顶点，检查它可以到达的所有顶点。假设v是u可以到达的一个顶点。若d[ed.to] &gt; d[u] + ed.w，那么d[ed.to] = d[u] + ed.w。并且，若v不在队列中，就将v放入队列。 重复上一步，直到队列为空。 讨论 上面在将顶点放入队列之前，会检查它是否已经在队列之中。目的是为了优化算法运行速度。将顶点放入队列的目的是检查它可以到达的顶点的最短距离值是否可以更小，既然顶点已经在队列中，那么再放入一次将没有意义。 为了检测负环图，可以增加一个数组，记录顶点被放入队列的次数。若发现它被放入队列的次数超过了n次，那么，必然存在负环。这是为什么呢？ 考虑顶点被放入队列的原因，是因为源点到该顶点之间出现了一条更短的道路。那么考虑一个极端的情况，一条最短路的每一次延伸的导致源点到该顶点出现了一条更短的道路:可以看到，这张图中，最长的最短路径经过了5个顶点，且每一次拓展都会使一个顶点的最短距离值变得更小，被放入队列。而即便如此，它也顶多被放入队列5次——不，甚至更少，因为这条最短路的终点就是他本身，并不会将自己放入最短路，因而这个顶点最多被放入4次。故，当一个顶点被放入队列超过n次，这张图中是必然存负圈的。实现12345678910111213141516171819202122232425262728293031bool spfa(int s)&#123; queue&lt;int&gt; q; memset(inq, 0, sizeof inq); memset(rcnt, 0, sizeof rcnt); for (int i = 0; i &lt; n; i++) &#123; d[i] = INF; p[i] = i; &#125; d[s] = 0; inq[s] = true; q.push(s); while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int e = head[u]; e != -1; e = edges[e].next) &#123; Edge ed = edges[e]; if (d[ed.to] &gt; d[u] + ed.w) &#123; d[ed.to] = d[u] + ed.w; p[ed.to] = u; if (!inq[ed.to]) &#123; q.push(ed.to); inq[ed.to] = true; if (++rcnt[ed.to] &gt; n) return false; &#125; &#125; &#125; &#125; return true;&#125; 完整代码见 Github 探究《算法竞赛入门经典》p364 刘汝佳大大留下了一个问题： 另外，如果图中有其他负圈但是s无法到达这个负圈，则上面的算法也无法找到。 他给了一个提示：增加一个顶点。 解决方法很简单，增加一个连通源点与其他所有顶点的顶点，且边权为0，即可。"},{"title":"Kruskal","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Kruskal/","text":"Kruskal 用途Kruskal算法用于求无向图的最小生成树。时间复杂度为O(nlogn)。 基本思想贪心法 原理步骤 将所有边按权值大小排序 用一个边集E表示选择了的边。清空这个边集。 按照权值从小到大的顺序依次考虑每条边。 若将这条边放入E中，不产生环，就将这条边放入E中。 反之，不放入。 考虑完每一条边后，E就是所求的最小生成树。 证明为什么若存在环，就不选择这条边呢？ 考虑一个存在环的生成树V。在这个环中，若去掉一条权值最大的边，那么这个环包含的节点仍然是连通的，且如此得到的生成树V1不会比原生成树V差。 实现难点那么，怎样判断某条边加入后是否会产生环呢？只要这条边连接的两个顶点u,v连通，那么这条边的加入就会产生环。因为u,v之间本来就有一条通路，加入该边之后将产生两条，也就形成环了。 怎样判断两条边是否连通呢？ 使用连通分量不易于合并，有一种方便高效的方法叫做并查集。 并查集原理 并查集将顶点以树的方式组织。所有连通的顶点形成一棵树，这棵树的树根称为这组顶点的代表元。判断两个顶点是否连通只要分别找到他们的树根（也就是代表元），比较是否相同。合并的方法也很简单，只要将某一组连通顶点的代表元的父亲设为另一组连通顶点的代表元即可。 实现添加递归找到树根（代表元）。12//初始化时将所有p[u]设为u自身int find(int u) &#123; return p[u]==u? u : find(p[u]); &#125; 但是有一个问题，如果树退化成一条链，那么每次寻找都要遍历一次树，速度很慢。 解决方法很简单，每次找到树根之后把u直接连接到树根即可。但代码相应复杂了一些。123456789int find(u)&#123; int v = p[u]; while (v != p[v]) &#123; v = p[v]; &#125; p[u] = v; return v;&#125; 合并合并的方法很简单。1234//合并u,v所在的树int pu = find(u);int pv = find(v);p[pu] = pv; //p[pv] = pu;也一样 代码解决了上面的难点，终于可以写出代码了。 123456789101112131415161718192021222324252627int eu[maxe], ev[maxe], ew[maxe]; // 表示边连接的两个顶点以及权值int que[maxe]; //排序int sel[maxe]; //是否选择了这条边int p[maxn]; //并查集int n; //顶点数int e; //边数void kruskal()&#123; memset(sel, 0, sizeof sel); //清空选择的边集 for (int i = 0; i &lt; n; i++) &#123; p[i] = i; //初始化p数组 &#125; for (int i = 0; i &lt; e; i++) &#123; que[i] = i; //主要是为了方便排序 &#125; sort(que, que + e, [](int l, int r) &#123; return ew[que[l]] &lt; ew[que[r]]; &#125;); for (int i = 0; i &lt; e; i++) &#123; int k = que[i]; int uroot = find(eu[k]); int vroot = find(ev[k]); if (uroot != vroot) &#123; sel[k] = 1; p[uroot] = vroot; &#125; &#125;&#125; 总结Kruskal的时间复杂度主要制约在于排序。由于使用了并查集，连通的判断与合并是非常快的，几乎可以看做常数时间。"},{"title":"快速读取整数","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/快速读取整数/","text":"原因可能大家都知道，在读数据的时候，scanf较之cin快上很多。但当某些题目数据量达到百万级别，就算使用scanf也太慢了。一共一秒钟的时间，读取数据都要用去大半。 解决方法当读取整数时，我们可以手动的读取字符，组成数字。这样速度将有巨大的提升。 原理&lt;cstdio&gt;库中有一个readchar()函数，读入一个字符，速度非常快。 我们将利用这一点快速的手动读入整数。 由于原理很简单，不多做阐述。 实现代码123456789void unsigned_qread(int&amp; d)&#123; d = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') d = d * 10 + ch - '0';&#125; 不足之处只可以读取正整数，不过已经可以满足大部分使用的需要了。 测试我写了一段代码测试比较scanf，cin，qread的速度。 可以看到，手动读取整数比其他两种快得多。通过这个方法，可以有效的避免数据量大的题目由于读取数据而造成的TLE。``&gt;) }&lt;/cstdio&gt;"},{"title":"Hexo","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Hexo/","text":"Hexo TestQuoteDo not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing Code_.compactUnderscore.js12_.compact([0, 1, false, 2, &apos;&apos;, 3]);=&gt; [1, 2, 3] GistGist服务不稳定。"},{"title":"Hello Hexo","permalink":"http://linyxus.xyz/blog/blog/2017/03/04/Hello-Hexo/","text":"Hello Hexo!终于装好了Hexo，和WP和Typecho比起来，Hexo深得我心0v0 静态网页带来的速度不用说，插件主题的丰富程度也是不错的。 但是之前Typecho上的数据还没迁移过来0v0所以现在一片空白。 测试一下Gist看看0v0 算了不试了，好卡啊。ww 有点问题Disqus不翻墙上不了？ Github在我写文章的时候又挂了。。怪不得刚刚用Gist卡住了。 Wait…现在上Github又要翻墙了？简直… 正经的话感觉折腾博客系统占用的时间甚至多于看书看NOIP复习小四门的时间了0v0关键是折腾完了其实也没有人看…(哭) 这次整完Hexo肯定不换新的了0v0 最后祝自己小四门4A2333333"}]}