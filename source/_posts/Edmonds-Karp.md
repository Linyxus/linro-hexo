---
title: Edmonds Karp
date: 2017-03-04 20:48:11
tags:
- C++
- 图论
categories:
- Noip
---
## 最大流问题
### 例子
最大流问题，或者说，物资运输问题。你的目标是把物资从一个地方运到另一个地方，你知道所有的站点以及各个中转站之间可以运输的最大物资量。需要求解的是运输物资的最大量。
![pic1](http://linfile.xyz/data/vip_data/f_4268.svg)

在上面的这一张图\\(V\\)中，所有顶点都表示一个站点，边表示站点之间的路，边权表示边连接的两个站点之间可以 **运输物资的最大量** 。道路和边一样，都是 **有向的** 。

从0到1最多可以运输多少物资呢？可以轻易的看出，是8个单位。如下图所示：

![pic2](http://linfile.xyz/data/vip_data/f_1152.svg)
### 定义
熟悉了增广路问题后，让我们对一些量进行符号规定：
- 容量 *(capacity)* 。对于\\(u \\in V, v \\in V\\)，它们之间可以运输的物资最大量（也即边的容量）记为\\(c(u,v)\\)。若\\(u, v\\)之间没有边，则\\(c(u,v)=0\\)
- 流量 *(flow)* 。对于\\(u \\in V, v \\in V\\)，它们之间已经榆树物资的量（也即边的流量）记为\\(f(u,v)\\)。
<!--more-->
### 性质
#### 性质一
$$f(u,v) \\leq c(u, v)$$

这是显然的，流量不能大于容量。
#### 性质二
$$f(u,v)=-f(v,u)$$

这也是显而易见的，从A到B运输了8单位就相当于从B到A运输了-8单位。
#### 性质三
对于任意除了起点与终点之外的顶点，流入量都应等于流出量。

由于世界生产力还不够发达，没必要把物资留在中转点而造成浪费:)

## Edmonds-Karp
### 介绍
Edmonds-Karp，也称为增广路算法，是求解最大流问题的一个常用算法。
### 原理
假设起点是s，终点是t。
- 在图中找出任意的一条s到t的通路。求出这条路可以通过的最大物资量，将这个物资量增加到每条边的流量中。
- 重复上一步，直到在图中找不到s到t的通路。

其中，s到t的通路称为一条 **增广路** ，将增广路的最大流量添加到每条边的流量中的过程称为 **增广**。

看似很简单，但且慢！别忘了，由于每一次增广我们都随便挑选了一条通路，然而我们并不知道我们挑选的路是否在最优解中，如何解决呢？

既然把物资从\\(u\\)运到\\(v\\)会增加\\(f(u,v)\\)那么显然，把物资从v运到u会减小\\(f(u,v)\\)，这与之前的定义中是一个道理。那么为了得到最优解，虽然只有\\(u\\)到\\(v\\)有一条有向边，我们仍然可以把物资从\\(v\\)运到\\(u\\)，来获得最优解，因为这样可以调整之前选择的不是那么好的最广路。

**反向边**

为了便与处理，我们引入 **反向边** 的概念。对于任意一条边\\( e=(u,v) \\)，加入它的反向边\\( e' = (v,u) \\)，并且满足：\\(f(e')=0, c(e')=0\\)。在算法中我们对边和反向边一视同仁，都只要满足上面提到的三条性质就行了，虽然，反向边的\\(c\\)是一个负数。

### 实现
在算法中，我们使用`BFS`找出s到t的通路，并求出这条通路的最大流量\\(\\Delta f\\)。

那么，\\(\\Delta f\\)怎么求呢？

用 **递推** 的方法：引入一个数组a[u]，表示s到u通路的最大流量。当顶点u从边e到达顶点v时，`a[v] = min(a[u], e.cap - e.flow)`。那么，\\(\\Delta f\\)就等于a[t]。

求出\\(\\Delta f\\)后，递归这条路上的每一条边\\(e\\)，设\\(e=(u,v)\\)，那么

$$f_{u,v}=f(u,v) + \\Delta f$$

$$f_{v,u}=f(v,u) - \\Delta f$$

并且将\\(\\Delta f\\)计入总流量
### 代码
#### 主体
```
int maxFlow(int s, int t)
{
    int flow = 0;
    while (true) {
        memset(a, 0, sizeof a);
        queue<int> q;
        q.push(s);
        a[s] = INF;
        while (!q.empty()) {
            int x = q.front(); q.pop();
            for (int e = head[x]; e != -1; e = edges[e].next) {
                Edge& ed = edges[e];
                if (!a[ed.to] && ed.cap > ed.flow) {
                    p[ed.to] = e;
                    a[ed.to] = min(a[x], ed.cap - ed.flow);
                    q.push(ed.to);
                }
            }
            if (a[t]) break;
        }
        if (!a[t]) break;
        for (int u = t; u != s; u = edges[p[u]].from) {
            edges[p[u]].flow += a[t];
            edges[p[u] ^ 1].flow -= a[t];
        }
        flow += a[t];
    }
    return flow;
}
```
*由于边和反向边在数组edges中序号紧邻（(0,1), (2,3)...)，且一个为奇数，一个为偶数。故，若边（或反向边）的序号为i，i^1就是反向边（或边）的序号。（^为异或运算符）*
#### 添加边与反向边
```
void append(int u, int v, int cap)
{
    Edge e;
    e.from = u;
    e.to = v;
    e.cap = cap;
    e.flow = 0;
    e.next = head[u];
    head[u] = cnt;
    edges[cnt++] = e;
}

void addEdge(int u, int v, int cap)
{
    append(u, v, cap);
    append(v, u, 0);
}
```
看看一开始的那张图所得到的解，经过处理后是这样的：
![img](http://linfile.xyz/data/vip_data/f_6249.svg)
其中，红色的边表示不能通过（容量满）。s到t已经没有通路了。
