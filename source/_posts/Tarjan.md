---
title: Tarjan
date: 2017-03-04 20:50:23
tags:
- C++
- 图论
categories:
- Noip
---
## 强连通子图
`Tarjan`是用以找出 *有向图* 中强连通子图的算法，那么，什么叫做 *强连通子图* 呢？

> 如果两个顶点可以相互通达，则称两个顶点强连通 *(strongly connected)* 。如果有向
图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分
量 *(strongly connected components)* 。
>——[百度百科](http://baike.baidu.com/link?url=6d_TxAkGUvJoZavApHLSyF82lJGH61GOX281z9OOnkoVGuIYQeDl7Q4Wl06axx-Q2q2MeVqxp8bquN6lL4qO5Qf1QUiTEv_Xy9kXXe4aIOC)

总结一下，强连通子图有如下性质：
设原图为\\(V\\)，子图为\\(V'\\)，那么
- 对于任意\\(u \\in V', u \\in V\\)。这是显然的，子图嘛。
- 对于任意\\(u,v \\in V'\\)，\\(u,v\\)之间互相存在通路。换言之，\\(u\\)可以到达
\\(v\\)，\\(v\\)也可到达\\(u\\)。
- 对于任意\\(u \\in V, v \\notin V\\)，\\(u,v\\)之间不存在互相之间的通路（\\(u\\)
到不了\\(v\\)，或\\(v\\)到不了\\(u\\)）。这是强连通子图的极大性。如果图里的顶点
还和在子图外的顶点强连通，为啥不把那个顶点也放进来呢？
- 一张图可以具有多个强连通子图，并且他们两两不相交。

## Tarjan
### 原理
Tarjan算法利用一个栈和递归 *(DFS)* 的方法，对问题进行求解。
<!--more-->
由于算法基于递归 *(DFS)* ，所以有些地方难于说清楚，那么我们来明确一下每一次递归
所作的事情。

每一次递归我们的知道的信息就是需要处理的顶点，还有之前递归所获取的信息。并且，
我们知道这个顶点之前一定没有被处理过。

那么，我们要做什么呢？首先，我们把这个顶点压进栈中，再从这个顶点继续向外拓展。如
果遇到了一个尚未访问过的顶点，就对它再调用`tarjan`。如果遇到了已经在栈中的点，那
说明这个点与之在同一个强连通子图中。

话说了这么多，究竟怎么求出强连通子图呢？我们知道，强连通子图中必然有一个顶点u是
第一个被访问到，也第一个入栈，不妨称为*根顶点*。当算法经过一步步拓展再次返回到这
个顶点时，可以说明这个强连通子图中的所有顶点都访问到了。只要把栈中在根顶点以上
包括根顶点的所有顶点弹出，那么这些弹出的顶点就是所求的强连通子图之一。

那怎样判断某个顶点是否是强连通子图的根顶点呢？**我们为每个顶点引入两个值**。
- index值。表示dfs访问到这个顶点的次序。是递增的。
- lowlink值。表示该顶点可到达顶点的最小index值。*（也就是该顶点可到达的入栈最早
的顶点的index值）*

于是，一切都很简单了。如果栈中的一个顶点是强连通子图的根顶点，那么`u.index ==
u.lowlink`是必然成立的。因为它自身就是那个最早的顶点了。

那么算法的处理过程就很好说清楚了。为了求得一个顶点的lowlink，我们检查从它出发的
每一条边。
- 如果边连接的顶点未被访问过，那么就先对它递归调用，求出他的lowlink，然
后与自己的比较，取更小的那一个赋给自己的lowlink。
- 如果边连接的顶点已经被访问过了。那么进行判断，如果不在栈中，说明并不属于一个
强连通子图，不处理。如果在一个栈中，说明处于一个强连通子图中，那么直接将它的low
link与自己的lowlink之间更小的一个赋给自己的lowlink。

最后，我们对传入的顶点u做一次判断。如果`u.index == u.lowlink`，说明它是强连通子图
的根顶点，我们就可以弹出栈中元素直到这个元素被弹出。

有个小问题，**怎样保证根顶点到栈顶的所有元素都位于同一个强连通子图呢？**

其实，dfs的递归调用也形成了一个调用栈。根顶点，设为\\(u\\)，是dfs最先访问到的，
故其调用栈中的元素\\(S_u\\)必然位于栈下方的位置。若后续dfs到了另一个强连通子图的
根顶点，设为\\(v\\)。执行将\\(v\\)所属的强连通子图内顶点从栈中弹出的那层dfs必然在
调用栈中位于\\(S_u\\)上方。所以当执行到\\(S_u\\)时，\\(S_v\\)已被从调用栈中弹出并
完成了它的使命（从栈中弹出元素）。

当然，弹出元素的时候我们还要做一些标记工作，不然不就白忙活了嘛。

时间复杂度：\\(O(nm)\\)

### 实现
```
void tarjan(int u)
{
    d[u] = low[u] = dcnt++;
    inStack[u] = true;
    s.push(u);
    int v;
    for (int e = head[u]; e != -1; e = edges[e].next) {
        v = edges[e].to;
        if (d[v] == -1) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else {
            if (inStack[v]) {
                low[u] = min(low[u], low[v]);
            }
        }
    }
    if (d[u] == low[u]) {
        do {
            v = s.top();
            s.pop();
            inStack[v] = false;
            idx[v] = icnt;
        } while (v != u);
        icnt++;
    }
}
```
