---
title: SPFA
date: 2017-03-04 20:43:41
tags:
- C++
- 图论
categories:
- Noip
---
## 介绍
`SPFA`是基于`Bellman-ford`的**队列优化**。一般来说，SPFA的速度快于`dijstra`和`Bellman-ford`，是图论中常用的一种算法。
## 原理
算法从源点出发，向外拓展，若一个顶点的最小距离值被更新了，就将他放入队列中等待处理，因为这个顶点最小距离的减少可能会造成**其他顶点的最短距离也减小**。

时间复杂度为\\(O(k|E|)\\) 。其中，\\(k\\)为每条边被处理的平均次数，而\\(E\\)是边集。
<!--more-->
## 步骤
- 初始化
- 将源点放入队列中
- 取出队列中的一个顶点，检查它可以到达的所有顶点。假设v是u可以到达的一个顶点。若`d[ed.to] > d[u] + ed.w`，那么`d[ed.to] = d[u] + ed.w`。并且，若v不在队列中，就将v放入队列。
- 重复上一步，直到队列为空。

## 讨论
- 上面在将顶点放入队列之前，会检查它是否已经在队列之中。目的是为了优化算法运行速度。将顶点放入队列的目的是检查它可以到达的顶点的最短距离值是否可以更小，既然顶点已经在队列中，那么再放入一次将没有意义。
- 为了检测负环图，可以增加一个数组，记录顶点被放入队列的次数。若发现它被放入队列的次数超过了n次，那么，**必然存在负环**。***这是为什么呢？*** 考虑顶点被放入队列的原因，是因为源点到该顶点之间出现了一条更短的道路。那么考虑一个极端的情况，一条最短路的每一次延伸的导致源点到该顶点出现了一条更短的道路:
![spfa1](http://linfile.xyz/data/vip_data/f_6386.svg)
可以看到，这张图中，最长的最短路径经过了5个顶点，且每一次拓展都会使一个顶点的最短距离值变得更小，被放入队列。而即便如此，它也顶多被放入队列5次——不，甚至更少，因为这条最短路的终点就是他本身，并不会将自己放入最短路，因而这个顶点最多被放入4次。**故，当一个顶点被放入队列超过n次，这张图中是必然存负圈的。**
## 实现
```
bool spfa(int s)
{
    queue<int> q;
    memset(inq, 0, sizeof inq);
    memset(rcnt, 0, sizeof rcnt);
    for (int i = 0; i < n; i++) {
        d[i] = INF;
        p[i] = i;
    }
    d[s] = 0;
    inq[s] = true;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (int e = head[u]; e != -1; e = edges[e].next) {
            Edge ed = edges[e];
            if (d[ed.to] > d[u] + ed.w) {
                d[ed.to] = d[u] + ed.w;
                p[ed.to] = u;
                if (!inq[ed.to]) {
                    q.push(ed.to);
                    inq[ed.to] = true;
                    if (++rcnt[ed.to] > n)
                        return false;
                }
            }
        }
    }
    return true;
}
```
*完整代码见 [Github](https://github.com/Linyxus/algorithms)*

## 探究
*《算法竞赛入门经典》p364* 刘汝佳大大留下了一个问题：

> 另外，如果图中有其他负圈但是s无法到达这个负圈，则上面的算法也无法找到。

他给了一个提示：增加一个顶点。

解决方法很简单，增加一个连通源点与其他所有顶点的顶点，且边权为0，即可。
