---
title: Dijstra
date: 2017-03-04 20:46:22
tags:
- C++
- 图论
categories:
- Noip
---
# 前言
这里的文章大多都是看了刘汝佳大大的《算法竞赛入门经典》之后写的，差不多就是把其内容复述一遍。一些我**难以理解，经过思考**的内容也会写出。

进入正题。
# 介绍
Dijstra是图论中用以求解单源最短路径*(也就是一个顶点到图中其他顶点的最短路径)* 的算法。

时间复杂度为$O(n^2)$。
<!--more-->
# 原理方法
 - 初始化
  - 将表示距离的数组d全部初始化成一个极大的值(称为INF)，将要求解的顶点的d[u]设为0
  - 将表示是否访问过的数组vis全部设为0。这里不要将要求解的顶点的vis值单独设置。
 - 处理
    - 在所有顶点中，遍历选择一个顶点，这个顶点满足如下条件。
        - 这个顶点的d值最小
        - 这个顶点被访问过，也就是`d[v] < INF`
        - 这个顶点没有被处理过，也就是`vis[v] != 1`
    - 处理这个上一步选择的顶点u。遍历这个顶点指向的所有顶点v。若`d[v] > d[u] + w[u, v]`，则更新d[v]，`d[v] = d[u] + w[u, v]`
    - 将上述步骤重复(n-1)次

**为什么重复(n-1)次呢？**

因为在n个顶点的图中，某个顶点到另一个顶点的**最短路最长也只有(n-1)条边**。

因为(n-1)条边正好经过n个顶点，若大于(n-1)条边，那么必然重复经过了某个顶点，即存在环。去掉环，所得结果不会更差。

![f_9145.jpg](http://linfile.xyz/data/vip_data/f_9145.jpg)

如图展示了一个含有四个顶点的图，其中1到4的最短路经过了4个顶点，3条边。

那么，回到原问题，**为什么重复(n-1)次呢？**

假设要求解的顶点是u，对于一个顶点v，假设u和v之间的最短路经过了d条边。那么每一轮重复，这条最短路都会向前拓展一条边。所以要求解出这条最短路需要重复d次。而经过上面的证明，图中最长的最短路最多只经过(n-1)条边，所以重复(n-1)次，就可以求出所有最短路了。

*下面用图片演示，便于理解。*

![f_3504.jpg](http://linfile.xyz/data/vip_data/f_3504.jpg)

# 实现
```C++
void dijstra(int u)
{
    memset(vis, 0, sizeof vis);
    const int INF = 2 << 30;
    for (int i = 0; i < n; i++)
        d[i] = INF;
    d[u] = 0;
    for (int k = 1; k < n; k++) { //repeat n-1 times
        int v;
        int minw = INF;
        for (int i = 0; i < n; i++) {
            if (d[i] < minw && !vis[i]) {
                v = i;
                minw = d[i];
            }
        }
        vis[v] = 1;
        for (int ed = head[v]; ed != -1; ed = edges[ed].next) {
            Edge ee = edges[ed];
            d[ee.to] = min(d[ee.to], d[v] + ee.w);
        }
    }
}
```
# 总结
其实在图论中，还是`SPFA`用的多。

# 顺带一提
代码都在 [Github](https://github.com/Linyxus/algorithms) 上。
